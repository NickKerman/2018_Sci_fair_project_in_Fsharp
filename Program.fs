open System

[<EntryPoint>]
let main argv =
  printfn "Welcome to the program, program!"

  // stuff goes here
  let planetRadius = 6378137.0  // Radius of Earth in meters
  let EarthMass = 5973600000000000000000000.0
  let mutable ExcessEscapeVelocity = None // My Independent Variable (in m/s)

  let mutable t = 0.0                 // time from launch in seconds
  let TimeStep = 0.01                 // Timefactor (seconds per cycle) lower = more accurate but slower
  let CounterLimit = 10               // How many iterations the counter will go up to before triggering and reseting
  let Counter = 0                     // counts iterations up until a given number then resets
  let simRunTime = 7200               // run time

  let mutable MachNo = 0.0
  let mutable StageNo = 1
  let mutable localPressure = 0.0     // pressure of local atmosphere in Pascals
  let mutable T = 15.0                // temperature of local atmosphere in degrees C
  let mutable h = 0.0                 // height in meters from sea level
  let C = 120.0                       // Sutherland's constant for air
  let To = 18.0                       // Reference temperature for viscosity equation
  let mutable u = 0.0                 // Viscosity of the air in centipoise
  let yg = 1.40                       // ratio of specific heat of at constant pressure to that at constant volume (is constant)
  let mutable c = 340.0               // local speed of sound in m/s
  let mutable MachNo = 0.0
  let M:float = v.getLaunchMass(StageNo)
  let mutable ThrustN = 0.0           // Thrust generated by currently used thrusters in newtons
  let mutable V = 0.0                 // current velocity m/s
  let EscV = 11186.0                  // Escape Velocity of Earth in m/s
  let mutable forceOfDrag = 0.0       // Drag force in Newton
  let mutable x = planetRadius        // x coordinate in meters (0,0 is center of earth)
  let mutable y = 0.0                 // y coordinate in meters
  let mutable VelocityX = 0.0         // Velocity along the x axis
  let mutable VelocityY = 0.0         // Velocity along the y axis
  let mutable PolarCoordMag = planetRadius // distance from center (polar coordinates)
  let mutable velocityAngle = 0.0
  let mutable PolarCoordDeg = 0.0     // angle from 0 in degrees (polar coordinates)
  let mutable xT = 0.0                // Thrust in x direction
  let mutable yT = 0.0                // Thrust in y direction
  let mutable thrustWeightRatio = 0.0
  let mutable F = 0.0                 // net force (after drag)
  let mutable xF = 0.0                // force along the x axis
  let mutable yF = 0.0                // force along the y axis
  let GravConst = 0.0000000000667359  //Gravitational constant

  let gs = 9.80665                    // gravity at surface level in m/s^2
  let mutable GravAng = 180.0           // direction of gravity's pull from the reference point of the spacecraft
  let mutable g = 9.80665             // current percieved acceleration due to gravity in m/s
  let mutable GravForceX = 0.0                // force of gravity in the x direction in Newtons
  let mutable GravForceY = 0.0                // force of gravity in the y direction in Newtons
  let mutable accel = 0.0             // current acceleration in m/s^2 (after gravity)
  let mutable HeadingDeg = 0.0        // heading in degrees, 0 is up (also opposite of direction of force) (where you are pointing)
  let mutable t_str = '0'             // time in seconds in string form for naming structures
  let mutable localAirDensity = 0.0   // density of local air in kg/m^3
  let MMA = 28.9644                   // molar mass of Earth's air in kg/mol
  let Rugc = 8314.32                  // universal gas constant J/mol/K
  let altRugc = 286.0                 // alternative universal gas constant
  let mutable FlightPathDeg = 0.0     // flight path angle in degrees (where you are going)
  let mutable GravForce = 0.0         // Force of gravity in Newtons
  
  let mutable stop = 0

  while (stop = 0) do
    t <- t + TimeStep
    //  atmospheric details
    if (h <= 11000.0) then                               // pressure, density, and temperature functions for under 11000 meters
        let temp_lapse_ratek = -0.0065
        T <- 15.0 + (temp_lapse_ratek * h)
        let static_pressure = 101325.0
        let standard_tempk = 288.15
        let layer_heightm = 0.0
        let default_layer_density = 1.2250
        let pa = standard_tempk / ((standard_tempk + (temp_lapse_ratek * (h - layer_heightm))))
        let pb = (gs * MMA) / (Rugc * temp_lapse_ratek)
        localPressure <- static_pressure * (pa ** pb)
        localAirDensity <- (default_layer_density * (pa ** (1.0 + pb)))
    elif (h <= 20000.0) then                            // pressure, density, and temperature functions for under 20000 meters
        T <- -56.5
        let default_layer_density = 0.36391
        let static_pressure = 22632.10
        let layer_heightm = 11000.0
        let standard_tempk = 216.65
        localPressure <- static_pressure * exp ((-gs * MMA * (h-layer_heightm)) / (Rugc * standard_tempk))
        localAirDensity <- default_layer_density * exp ((-gs * MMA * (h-layer_heightm)) / (Rugc * standard_tempk))
    elif (h <= 32000.0) then                            // pressure, density, and temperature functions for under 32000 meters
        let static_pressure = 5474.89
        let standard_tempk = 216.65
        let temp_lapse_ratek = 0.001
        let layer_heightm = 20000.0
        T <- -56.5 + temp_lapse_ratek * (h-layer_heightm)
        let default_layer_density = 0.08803
        let pa = standard_tempk / ((standard_tempk+(temp_lapse_ratek*(h-layer_heightm))))
        let pb = (gs * MMA) / (Rugc * temp_lapse_ratek)
        localPressure <- static_pressure * (pa ** pb)
        localAirDensity <- default_layer_density * (pa ** (1.0+pb))
    elif (h <= 47000.0) then                            // pressure, density, and temperature functions for under 47000 meters
        let static_pressure = 868.02
        let standard_tempk = 228.65
        let layer_heightm = 32000.0
        let temp_lapse_ratek = 0.0028
        T <- -56.5 + 0.0028*(h-layer_heightm)
        let default_layer_density = 0.01322
        let pa = standard_tempk / ((standard_tempk+(temp_lapse_ratek * (h-layer_heightm))))
        let pb = ((gs*MMA) / (Rugc*temp_lapse_ratek))
        localPressure <- static_pressure * (pa ** pb)
        localAirDensity <- default_layer_density * (pa ** (1.0+pb))
    elif (h <= 51000.0) then                            // pressure, density, and temperature functions for under 51000 meters
        T <- -2.5
        let static_pressure = 110.91
        let standard_tempk = 270.65
        let layer_heightm = 47000.0
        let default_layer_density = 0.00143
        localPressure <- static_pressure * exp((-gs*MMA*(h-layer_heightm))/(Rugc*(standard_tempk)))
        localAirDensity <- default_layer_density * exp((-gs*MMA*(h-layer_heightm))/(Rugc*(standard_tempk)))
    elif (h <= 71000.0) then                            // pressure, density, and temperature functions for under 71000 meters
        T <- -2.5 + (-0.0028*(h-51000.0))
        let static_pressure = 66.94
        let temp_lapse_ratek = -0.0028
        let standard_tempk = 270.65
        let layer_heightm = 51000.0
        let default_layer_density = 0.00086
        let pa = standard_tempk / ((standard_tempk + (temp_lapse_ratek * (h - layer_heightm))))
        let pb = ((gs * MMA)/(Rugc * temp_lapse_ratek))
        localPressure <- static_pressure * (pa ** pb)
        localAirDensity <- default_layer_density * (pa ** (1.0+pb))
    elif (h <= 86000.0) then                            // pressure and temperature functions for under 86000 meters
        T <- -58.5 + (-0.002 * (h-71000.0))
        let static_pressure = 3.96
        let temp_lapse_ratek = -0.002
        let standard_tempk = 214.65
        let layer_heightm = 71000.0
        let default_layer_density = 0.000064
        let pa = standard_tempk/((standard_tempk+(temp_lapse_ratek*(h-layer_heightm))))
        let pb = ((gs*MMA)/(Rugc*temp_lapse_ratek))
        localPressure <- static_pressure * (pa ** pb)
        localAirDensity <- default_layer_density * (pa ** (1.0+pb))
    else
        localPressure <- 0.0
        localAirDensity <- 0.0

    thrustWeightRatio <- ThrustN / (M * g)

    c <- sqrt(yg * altRugc * (T+273.15))                                  // Local speed of sound (m/s)
    MachNo <- V/c
    u <- 0.01827 * ((To + 273.15 + C) / (T+ 273.15 + C)) * (T / To ** 3.0/2.0) // Viscocity from temperature and sutherland's constant in centipoise
    let forceDragX = forceOfDrag * cos(math.radians(FlightPathDeg))     // Force of drag in newtons along x
    let forceDragY = forceOfDrag * sin(math.radians(FlightPathDeg))     // Force of drag in newtons along y
    xT <- ThrustN * cos(math.radians(HeadingDeg))                       // thrust along the x axis
    yT <- ThrustN * sin(math.radians(HeadingDeg))                       // thrust along the y axis
    g <- gs * (planetRadius/PolarCoordMag ** 2.0)                       // acceleration due to gravity
    GravAng <- PolarCoordDeg                                            // Direction of acceleration due to gravity from spacecraft's reference point in degrees
    GravForce <- g*M                                                    // Force of gravity in Newtons
    GravForceX <- 0.0 - (GravForce * cos(math.radians(GravAng)))        // Force due to gravity (in Newtons) in the x direction from g and the negative of the polar position in degrees
    GravForceY <- 0.0 - (GravForce * sin(math.radians(GravAng)))        // Force due to gravity (in Newtons) in the y direction from g and the negative of the polar position in degrees
    xF <- xT + GravForceX + forceDragX                                  // Total force along x in Newtons
    yF <- yT + GravForceY + forceDragY                                  // Total force along y in Newtons
    let Ax = xF/M                                                       // Acceleration along x in m/s
    let Ay = yF/M                                                       // Acceleration along y in m/s
    accel <- sqrt ((Ax ** 2.0) + (Ay ** 2.0))                           // Acceleration as axes into a vector
    VelocityX <- VelocityX + (Ax*TimeStep)                              // speed in x changes due to acceleration
    VelocityY <- VelocityY + (Ay*TimeStep)                              // speed in y changes due to acceleration
    V <- sqrt(VelocityX ** 2.0) + (VelocityY ** 2.0)
    x <- x + (VelocityX*TimeStep)                                       // position in x changes due to acceleration along x
    y <- y + (VelocityY*TimeStep)
    
    PolarCoordDeg <- math.degrees(math.atan2(y, x))
    if PolarCoordDeg < 0.0 then
        PolarCoordDeg <- PolarCoordDeg + 360.0
    PolarCoordMag <- sqrt((x ** 2.0) + (y ** 2.0))

    h <- PolarCoordMag - planetRadius

    let velocityAngle = math.degrees(math.atan2(VelocityY, VelocityX))
    FlightPathDeg <-
      if velocityAngle < 0.0 then
          velocityAngle + 360.0
      elif velocityAngle > 360.0 then
          velocityAngle - 360.0
      else
          velocityAngle

    let dynamicQ = localPressure * (V ** 2.0) * 0.5
    if (h < 0.0) then
        plsStlop <- 1
        printfn ("BOOOOM!  Hit the ground at t=%s" % t)

    //HeadingDeg, kickHeight, kickAngleDeg = v.PitchControl(t, TimeStep, h, FlightPathDeg, HeadingDeg, PolarCoordDeg)
    HeadingDeg, kickAngleDeg, kickHeight = v.PitchControl(t, TimeStep, h, FlightPathDeg, HeadingDeg, PolarCoordDeg, dynamicQ)

  // Accumulate records every 100 itterations
    Counter = (Counter + 1)
    if (Counter = CounterLimit) then
        Counter = 0;
        all_t.append(t)                  // These lines record the current values in the one_time structre
        all_y.append(y)
        all_h.append(h)
        all_StageNo.append(StageNo)
        all_localPressure.append(localPressure)
        all_accel.append(accel)
        all_localAirDensity.append(localAirDensity)
        all_Ax.append(Ax)
        all_Ay.append(Ay)
        all_HeadingDeg.append(HeadingDeg)
        all_V.append(V)
        all_VelocityX.append(VelocityX)
        all_VelocityY.append(VelocityY)
        all_x.append(x)
        all_GravForce.append(GravForce)
        all_forceOfDrag.append(forceOfDrag)
        all_FlightPathDeg.append(FlightPathDeg)
        all_GravAng.append(GravAng)
        all_ThrustN.append(ThrustN)
        all_PolarCoordMag.append(PolarCoordMag)
        all_PolarCoordDeg.append(math.radians(PolarCoordDeg))
        all_dynamicQ.append(dynamicQ)
    if (t >= simRunTime) then
        stop <- 1
    printfn ("Done! Stop value:%s" % stop)
    # plot(all_t, all_FlightPathDeg, ";FlightPathDeg;");
# plot(all_t, all_V, ";V;");
# plot(all_t, all_GravAng, ";GravAng;");
# plot(all_t, all_GravForceX, ";GravForceX;", all_t, all_GravForceY, ";GravForceY;");
# plot(all_t, all_forceDragX, ";forceDragX;", all_t, all_forceDragY, ";forceDragY;");
# plot(all_t, all_h, ";Altitude (m);");
# plot(all_t, all_ThrustN, ";Thrust (N);");
# plot(all_t, all_xT, ";X Thrust;", all_t, all_yT, ";Y Thrust;");
# plot(all_t, all_y, ";Y position (m);", all_t, all_x, ";X position (m);");

timeIndexAtBurnout = None
if v.timeAtBurnout is not None:
  timeIndexAtBurnout = int((v.timeAtBurnout/TimeStep)/CounterLimit) - 1

print ('position at burnout was (%s,%s) meters' % (all_x[timeIndexAtBurnout], all_y[timeIndexAtBurnout]))
print ('velocity at burnout was %s m/s' % all_V[timeIndexAtBurnout])
print ('Altitude at burnout was %s meters' % all_h[timeIndexAtBurnout])
EscV = math.sqrt((2*GravConst*EarthMass)/all_PolarCoordMag[timeIndexAtBurnout])
print ('escape velocity at %s meters is = %s m/s' % (all_h[timeIndexAtBurnout], EscV))
ExcessEscapeVelocity = math.sqrt((math.pow(V,2))-(math.pow(EscV,2)))
print ('Excess escape velocity = %s' %ExcessEscapeVelocity)


# X and Y over time

graph_dpi = 100

plt.figure()
fig, ax1 = plt.subplots()
fig.set_size_inches(11, 5)

ax1.plot(all_t, all_y, 'b-')
ax1.set_xlabel('time (s)')
ax1.set_ylabel('Y position (m)', color='b')
ax1.tick_params('y', colors='b')

ax2 = ax1.twinx()
ax2.plot(all_t, all_x, 'r-')
ax2.set_ylabel('X position (m)', color='r')
ax2.tick_params('y', colors='r')

plt.savefig('G_x_y_vs_time.png', dpi=graph_dpi)

# X versus Y

plt.figure()
fig, ax1 = plt.subplots()
fig.set_size_inches(11, 11)

ax1.set_xlabel('X position (m)')
ax1.set_ylabel('Y position (m)')
xymax = max(max(all_x), max(all_y)) + 200000  # find highest value in both sets
xymin = min(min(all_x), min(all_y)) - 200000  # find lowest value
if xymin < 0:                                 # if lowest is below 0 it might need a bigger frame
  xymax = max(xymax, 0-xymin)

ax1.set_ylim([0-xymax,xymax])
ax1.set_xlim([0-xymax,xymax])

def gimmeACircle(radius):
    circleX = []
    circleY = []
    for degRange in range(0, 360, 1):
        circleX.append(radius * math.sin(math.radians(degRange)))
        circleY.append(radius * math.cos(math.radians(degRange)))
    return circleX, circleY

earthSurfaceCircleX, earthSurfaceCircleY = gimmeACircle(planetRadius)
topAtmosLayerX, topAtmosLayerY = gimmeACircle(planetRadius + 86000)

ax1.scatter(all_x, all_y, s=3, c='red')
ax1.scatter(earthSurfaceCircleX, earthSurfaceCircleY, s=3, c='green')
ax1.scatter(topAtmosLayerX, topAtmosLayerY, s=1, c='blue')

if timeIndexAtBurnout is not None:
  burnCoordX = [all_x[timeIndexAtBurnout]]
  burnCoordY = [all_y[timeIndexAtBurnout]]
  ax1.scatter(burnCoordX, burnCoordY, s=50, c='red')
  ax1.scatter(burnCoordX, burnCoordY, s=20, c='white')

plt.savefig('G_x_y_scatter.png', dpi=graph_dpi)

# Accel, ax, and ay graph

plt.figure()
fig2, ax1 = plt.subplots()
fig2.set_size_inches(11, 5)

if timeIndexAtBurnout is not None:
  burnCoordX = [all_t[timeIndexAtBurnout]]
  burnCoordY = [all_accel[timeIndexAtBurnout]]
  ax1.scatter(burnCoordX, burnCoordY, s=50, c='blue')
  ax1.scatter(burnCoordX, burnCoordY, s=20, c='white')

ax1.plot(all_t, all_accel, 'b-')
ax1.set_xlabel('time (s)')
ax1.set_ylabel('Accel (m/s2)', color='b')
ax1.tick_params('y', colors='b')

ax2 = ax1.twinx()

if timeIndexAtBurnout is not None:
  burnCoordX = [all_t[timeIndexAtBurnout]]
  burnCoordY = [all_Ax[timeIndexAtBurnout]]
  ax2.scatter(burnCoordX, burnCoordY, s=50, c='red')
  ax2.scatter(burnCoordX, burnCoordY, s=20, c='white')

if timeIndexAtBurnout is not None:
  burnCoordX = [all_t[timeIndexAtBurnout]]
  burnCoordY = [all_Ay[timeIndexAtBurnout]]
  ax2.scatter(burnCoordX, burnCoordY, s=50, c='green')
  ax2.scatter(burnCoordX, burnCoordY, s=20, c='white')

ax2.plot(all_t, all_Ax, 'r-')
ax2.plot(all_t, all_Ay, 'g-')
ax2.set_ylabel('Accel along X axis', color='r')
ax2.set_ylabel('Accel along Y axis', color='g')
ax2.tick_params('y', colors='r')

plt.savefig('G_accel.png', dpi=graph_dpi)

# Air density and height and pressure

plt.figure()
fig2, ax1 = plt.subplots()
fig2.set_size_inches(11, 5)

ax1.plot(all_t, all_localAirDensity, 'b-')
ax1.set_xlabel('time (s)')
ax1.set_ylabel('Local air density', color='b')
ax1.tick_params('y', colors='b')

ax2 = ax1.twinx()
ax2.plot(all_t, all_localPressure, 'g-')
ax2.set_ylabel('Local pressure (Pascals)', color='g')
ax2.tick_params('y', colors='g')

ax2 = ax1.twinx()
ax2.plot(all_t, all_h, 'r-')
ax2.set_ylabel('Height (m)', color='r')
ax2.tick_params('y', colors='r')

plt.savefig('G_local_air_density-height.png', dpi=graph_dpi)

# VelocityX and VelocityY

plt.figure()
fig2, ax1 = plt.subplots()
fig2.set_size_inches(11, 5)

ax1.plot(all_t, all_VelocityX, 'b-')
ax1.set_xlabel('time (s)')
ax1.set_ylabel('VelocityX', color='b')
ax1.tick_params('y', colors='b')

if timeIndexAtBurnout is not None:
  burnCoordX = [all_t[timeIndexAtBurnout]]
  burnCoordY = [all_VelocityX[timeIndexAtBurnout]]
  ax1.scatter(burnCoordX, burnCoordY, s=50, c='blue')
  ax1.scatter(burnCoordX, burnCoordY, s=20, c='white')

ax2 = ax1.twinx()
ax2.plot(all_t, all_VelocityY, 'g-')
ax2.set_ylabel('VelocityY', color='g')
ax2.tick_params('y', colors='g')

if timeIndexAtBurnout is not None:
  burnCoordX = [all_t[timeIndexAtBurnout]]
  burnCoordY = [all_VelocityY[timeIndexAtBurnout]]
  ax2.scatter(burnCoordX, burnCoordY, s=50, c='green')
  ax2.scatter(burnCoordX, burnCoordY, s=20, c='white')

plt.savefig('G_velocityx_velocityy.png', dpi=graph_dpi)

# forceOfDrag and FlightPathDeg and HeadingDeg

plt.figure()
fig2, ax1 = plt.subplots()
fig2.set_size_inches(11, 5)

ax1.plot(all_t, all_forceOfDrag, 'b-')
ax1.set_xlabel('time (s)')
ax1.set_ylabel('forceOfDrag', color='b')
ax1.tick_params('y', colors='b')

ax2 = ax1.twinx()
ax2.plot(all_t, all_FlightPathDeg, 'g-')
ax2.set_ylabel('FlightPathDeg', color='g')
ax2.tick_params('y', colors='g')

ax2 = ax1.twinx()
ax2.plot(all_t, all_HeadingDeg, 'r-')
ax2.set_ylabel('HeadingDeg', color='r')
ax2.tick_params('y', colors='r')

plt.savefig('G_forceOfDrag_FlightPathDeg_Head.png', dpi=graph_dpi)
#plt.savefig('G_Kick-%s-KickHeight-%s-forceOfDrag_FlightPathDeg_Head.png' % (kickAngleDeg,kickHeight),dpi = graph_dpi)

# ThrustN

plt.figure()
fig2, ax1 = plt.subplots()
fig2.set_size_inches(11, 5)

ax1.plot(all_t, all_ThrustN, 'b-')
ax1.set_xlabel('time (s)')
ax1.set_ylabel('ThrustN', color='b')
ax1.tick_params('y', colors='b')

if timeIndexAtBurnout is not None:
  burnCoordX = [all_t[timeIndexAtBurnout]]
  burnCoordY = [all_ThrustN[timeIndexAtBurnout]]
  ax1.scatter(burnCoordX, burnCoordY, s=50, c='blue')
  ax1.scatter(burnCoordX, burnCoordY, s=20, c='white')

plt.savefig('G_ThrustN.png', dpi=graph_dpi)

# GravAng

plt.figure()
fig2, ax1 = plt.subplots()
fig2.set_size_inches(11, 5)

ax1.plot(all_t, all_GravAng, 'b-')
ax1.set_xlabel('time (s)')
ax1.set_ylabel('GravAng', color='b')
ax1.tick_params('y', colors='b')

ax2 = ax1.twinx()
ax2.plot(all_t, all_GravForce, 'g-')
ax2.set_ylabel('GravForce', color='g')
ax2.tick_params('y', colors='g')

plt.savefig('G_GravAng_GravForce.png', dpi=graph_dpi)

#Position
#plt.figure()
#ax = plt.subplot(111, polar=True)
#stepped_d = []
#stepped_m = []
#skip = 0
#index = 0
#while index < len(all_PolarCoordDeg):
#   d = all_PolarCoordDeg[index]
#    m = all_PolarCoordMag[index]
#    skip = skip + 1
#    if skip > 50:
#        stepped_d.append(d)
#        stepped_m.append(m)
#        skip = 0
#    index = index + 1
#ax.scatter(all_PolarCoordDeg, all_PolarCoordMag, s=1.1, c='red')
#ax.plot(q, all_PolarCoordMag, 'r-')
#ax.scatter(stepped_d, stepped_m, s=2, c='black')
#print (all_PolarCoordDeg)
#plt.savefig('G_radial_flight_path.png',dpi = 700)
#plt.savefig('G_Kick-%s-Height-%s-flight_path.png' % (kickAngleDeg,kickHeight),dpi = 1500)

plt.figure()
fig2, ax1 = plt.subplots()
fig2.set_size_inches(11, 5)

ax1.plot(all_t, all_dynamicQ, 'b-')
ax1.set_xlabel('time (s)')
ax1.set_ylabel('Dynamic Pressure', color='b')
ax1.tick_params('y', colors='b')

if timeIndexAtBurnout is not None:
  burnCoordX = [all_t[timeIndexAtBurnout]]
  burnCoordY = [all_dynamicQ[timeIndexAtBurnout]]
  ax1.scatter(burnCoordX, burnCoordY, s=50, c='blue')
  ax1.scatter(burnCoordX, burnCoordY, s=20, c='white')

plt.savefig('G_DynamicQ.png', dpi=graph_dpi)

    0